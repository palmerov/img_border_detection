%!TEX root = main.tex
\section{Conclusiones}
\label{sec:conclusions}

En este trabajo se ha implementado el kernel de detección de bordes por magnitud del gradiente \(G[i] = \sqrt{G_x[i]^2 + G_y[i]^2}\) en C++ moderno en cuatro variantes: línea base escalar, vectorización automática del compilador, vectorización guiada (OpenMP SIMD) y vectorización explícita (Intel AVX2). Se ha analizado el rendimiento y la eficiencia de vectorización con Intel Advisor.

Los tiempos de ejecución directa (en ms) son: escalar 0,52; auto 0,34; guiada 0,27; explícita 0,24. La variante explícita (AVX2) es la más rápida, con una aceleración de aproximadamente 2,2\(\times\) frente a la escalar y 1,1\(\times\) frente a la guiada. Con Intel Advisor se confirmó que las tres variantes vectorizadas (auto, guiada y explícita) alcanzan 100\% de tiempo en un bucle vectorizado (AVX); solo la escalar queda en 0\%.

Advisor reporta 0\% de vectorización para escalar y 100\% para las tres variantes vectorizadas. Las diferencias de rendimiento entre estas últimas se deben al mayor grado de optimización de la guiada y la explícita frente a la auto-vectorización.

En resumen, las tres variantes vectorizadas (auto, guiada y explícita) mejoran frente a la línea base escalar; la explícita AVX2 es la más rápida y ofrece el máximo control a costa de portabilidad. Como trabajo futuro se podría considerar el uso de imágenes de mayor tamaño, otros kernels (p.ej.\ Canny completo) o la comparación con implementaciones en GPU.
