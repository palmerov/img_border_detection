%!TEX root = main.tex
\section{Introducción}
\PARstart{L}{a} detección de bordes es una operación fundamental en visión por computador, procesamiento de imágenes médicas, percepción robótica y como etapa de preprocesado para redes neuronales convolucionales. Los bordes marcan cambios bruscos de intensidad que suelen corresponder a contornos de objetos y permiten reducir la imagen a información estructural: formas, contornos y regiones. Desde el punto de vista computacional, los bordes se caracterizan por una magnitud del gradiente elevada, por lo que los enfoques estándar utilizan operadores como Sobel, Prewitt o Canny~\cite{canny1986}.

El kernel numérico en el que nos centramos es el cómputo de la magnitud del gradiente: en cada píxel \(i\), la fuerza del borde viene dada por
\begin{equation}
G[i] = \sqrt{G_x[i]^2 + G_y[i]^2},
\end{equation}
donde \(G_x\) y \(G_y\) son los gradientes horizontal y vertical obtenidos convolucionando la imagen con kernels pequeños (p.ej.\ Sobel 3\(\times\)3). Este kernel está limitado por cómputo y es muy regular, lo que lo convierte en un buen candidato para la vectorización SIMD en CPUs modernas.

El objetivo de este trabajo es comparar tres estrategias de vectorización---automática (solo compilador), guiada (directivas como OpenMP SIMD) y explícita (intrinsics SIMD escritas a mano)---sobre una implementación en C++ de este kernel, y analizar su rendimiento y eficiencia de vectorización con Intel Advisor. Implementamos una línea base escalar más las tres versiones vectorizadas, las ejecutamos bajo Intel Advisor para obtener tiempos y métricas de vectorización, y presentamos los resultados en este artículo. El documento se organiza así: la Sección~\ref{sec:background} repasa el kernel y los conceptos de vectorización; la Sección~\ref{sec:method} describe la implementación y la metodología basada en Advisor; la Sección~\ref{sec:experimental} presenta los resultados experimentales; la Sección~\ref{sec:conclusions} resume las conclusiones y líneas futuras.
