%!TEX root = main.tex
\section{Metodología}
\label{sec:method}

\subsection{Implementación escalar}

Implementamos el kernel de detección de bordes en C++ moderno (C++17). La versión escalar consta de:
\begin{enumerate}
\item Carga de una imagen en escala de grises (formato PGM) en un buffer contiguo de \texttt{double}.
\item Convolución de la imagen con los kernels de Sobel \(G_x\) y \(G_y\) 3\(\times\)3 con salida de mismo tamaño (los píxeles de borde se omiten o replican). Dos bucles anidados sobre filas y columnas calculan cada píxel de salida con una ventana 3\(\times\)3 (esténcil de 9 puntos).
\item Cálculo de la magnitud del gradiente \(G[i] = \sqrt{G_x[i]^2 + G_y[i]^2}\) en un único bucle sobre todos los píxeles.
\end{enumerate}
No se usan directivas SIMD ni intrinsics; sirve como línea base y como referencia de ``sin vectorización'' para Intel Advisor.

El Algoritmo~\ref{alg:scalar-loop} detalla el bucle principal de la convolución (un píxel por iteración) y el bucle de magnitud. En la variante escalar ambos bucles son puramente escalares; en las variantes guiada y explícita estos mismos bucles son el objetivo de la vectorización.

\begin{algorithm}[htb]
\caption{Bucle escalar: convolución y magnitud}
\label{alg:scalar-loop}
\begin{algorithmic}[1]
\Require Imagen \(I\), kernels \(K_x\), \(K_y\) 3\(\times\)3; dimensiones \(H\), \(W\)
\Ensure Imagen de bordes \(G\)
\State Inicializar \(G_x\), \(G_y\) del tamaño de \(I\)
\For{\(y \gets 1\) \textbf{to} \(H-2\)}
\For{\(x \gets 1\) \textbf{to} \(W-2\)}
\State \(gx \gets 0\); \(gy \gets 0\)
\For{\(dy \gets -1\) \textbf{to} \(1\)}
\For{\(dx \gets -1\) \textbf{to} \(1\)}
\State \(gx \gets gx + I[y+dy,x+dx] \cdot K_x[dy+1,dx+1]\)
\State \(gy \gets gy + I[y+dy,x+dx] \cdot K_y[dy+1,dx+1]\)
\EndFor
\EndFor
\State \(G_x[y,x] \gets gx\); \(G_y[y,x] \gets gy\)
\EndFor
\EndFor
\For{cada píxel \(i\) en el interior}
\State \(G[i] \gets \sqrt{G_x[i]^2 + G_y[i]^2}\)
\EndFor
\State \Return \(G\)
\end{algorithmic}
\end{algorithm}

\subsection{Versión auto-vectorizada}

El mismo código fuente se compila con optimización agresiva y flags específicos de arquitectura: \texttt{-O3 -march=native} (con Intel oneAPI se usa \texttt{icpx}). No se añaden pragmas ni intrinsics. Se espera que el compilador auto-vectorice los bucles de convolución y magnitud cuando sea legal. Esta variante se denomina ``auto'' en los resultados.

\subsection{Vectorización guiada (implícita)}

Una segunda variante se construye con la misma estructura algorítmica pero con \texttt{\#pragma omp simd} aplicado al bucle interno de la convolución y al bucle de magnitud. El proyecto se enlaza con OpenMP (\texttt{-fiopenmp} en Intel oneAPI). Así se guía al compilador para generar código SIMD en esos bucles y Advisor puede reportar la vectorización guiada.

\subsection{Vectorización explícita}

Una tercera variante implementa la convolución y el cómputo de la magnitud usando intrinsics Intel AVX2 (\texttt{\_mm256\_*}). Se procesan cuatro valores \texttt{double} por iteración (registros de 256 bits). El bucle interno de la convolución se desenrolla para calcular cuatro píxeles consecutivos cada vez; el resto se trata con un epílogo escalar. La etapa de magnitud usa \texttt{\_mm256\_loadu\_pd}, \texttt{\_mm256\_mul\_pd}, \texttt{\_mm256\_add\_pd} y \texttt{\_mm256\_sqrt\_pd}, con cola escalar. Esta variante se compila con \texttt{-O3 -march=native} para disponer de FMA y otras instrucciones.

\subsection{Análisis de rendimiento con Intel Advisor}

La compilación se realiza con \texttt{icpx} y los parámetros necesarios en cada caso: escalar sin auto-vectorización; auto con \texttt{-O3 -march=native}; guiada con \texttt{-O3 -march=native -fiopenmp}; explícita con \texttt{-O3 -march=native}. Para cada variante se ejecutó el binario bajo Intel Advisor (Survey) sobre una imagen de entrada fija y se utilizaron los informes de vectorización para obtener métricas como porcentaje de código vectorizado y eficiencia del bucle. Las imágenes de entrada son PGM en escala de grises; el tamaño y la ruta se mantienen fijos en todas las ejecuciones para que tiempos y métricas sean comparables.
